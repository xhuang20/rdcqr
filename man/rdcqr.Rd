% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/rdcqr.R
\name{rdcqr}
\alias{rdcqr}
\title{Local composite quantile estimation in regression discontinuity}
\usage{
rdcqr(y, x, fuzzy = NULL, t0 = 0, cutoff = 0, q = 5, bandwidth =
  "rot", kernel.type = "triangular", maxit = 20, tol = 1.0e-3, parallel =
  TRUE, numThreads = "default", grainsize = 1, llr.residuals = FALSE,
  ls.derivative = TRUE)
}
\arguments{
\item{y}{A vector of treatment outcomes.}

\item{x}{A vector of covariates.}

\item{fuzzy}{A vector of treatment assignments in a fuzzy RD. Defaults to
\code{NULL} in a sharp RD. 1 for receiving the treatment and 0 otherwise.}

\item{t0}{Treatment effect under the null. Defaults to 0.}

\item{cutoff}{Cutoff for treatment assignment. Defaults to 0.}

\item{q}{Number of quantiles to be used in estimation. Defaults to 5. It
needs to be an odd number.}

\item{bandwidth}{In a sharp RD, if the supplied bandwidth is a numeric vector
of length two, the first element is the bandwidth for data below the cutoff
and the second element is the bandwidth for data above the cutoff. In a
fuzzy RD, the supplied bandwidth vector needs to have four elements in it:
the first two bandwidths are for treatment outcomes below and above the
cutoff and the last two bandwidths are for treatment assignments below and
above the cutoff. If it is a string, the following types of bandwidth
selector are provided: \enumerate{ \item \code{rot}: Rule-of-thumb
bandwidth selector. Two bandwidths are used on each side of the cutoff,
each of which is a transform of the rule-of-thumb bandwidth for the local
linear regression.\item \code{adj.mseone}: One bandwidth based on the
adjusted MSE function. \item \code{adj.msetwo}: Two bandwidths based on the
adjusted MSE function. \item \code{msetwo}: Two bandwidths based on the MSE
function, each of which is the MSE-optimal bandwidth.  }}

\item{kernel.type}{Kernel type that includes \enumerate{ \item
\code{triangular}: triangular kernel. \code{kernID = 0}. \item
\code{biweight}:   biweight kernel. \code{kernID = 1}. \item
\code{epanechnikov}:  Epanechnikov kernel. \code{kernID = 2}. \item
\code{gaussian}:  Gaussian kernel. \code{kernID = 3}. \item \code{tricube}:
tricube kernel. \code{kernID = 4}. \item \code{triweight}:  triweight
kernel. \code{kernID = 5}. \item \code{uniform}:  uniform kernel
\code{kernID = 6}. }}

\item{maxit}{Maximum iteration number in the MM algorithm for quantile
estimation. Defaults to 20.}

\item{tol}{Convergence criterion in the MM algorithm. Defaults to 1.0e-3.}

\item{parallel}{A logical value specifying whether to use parallel computing.
Defaults to  \code{TRUE}.}

\item{numThreads}{Number of threads used in parallel computation. The option
\code{auto} uses all threads. Defaults to the number of cores minus 1.}

\item{grainsize}{Minimum chunk size for parallelization. Defaults to 1.}

\item{llr.residuals}{Whether to use residuals from the local linear
regression as the input to compute the LCQR standard errors and the
corresponding bandwidths. Defaults to \code{FALSE}. If this option is set
to \code{TRUE}, the treatment estimate and the bias-correction is still
done in LCQR. We use the same kernel function used in LCQR in the local
linear regression to obtain the residuals and use them to compute the
unadjusted and adjusted asymptotic standard errors and the bandwidths. This
option will improve the speed but its accuracy is unclear. One can use this
opition to get a quick estimate of the standard errors when the sample size
is large.}

\item{ls.derivative}{Whether to use a global quartic and quintic polynomial
to estimate the second and third derivatives of the conditional mean
function. Defaults to TRUE.}
}
\value{
\code{rdcqr} returns a list with the following components:
\item{estimate}{Treatment effect estimate and the bias-corrected treatment
estimate} \item{se}{Asymptotic standard error and the adjusted asymptotic
standard error} \item{bws}{Bandwidths used in estimation. There are two and
four bandwidths for sharp and fuzzy RD, respectively. In a fuzzy RD, the
first two bandwidths are associated with the treatment outcome variable
below and above the cutoff. The last two bandwidths are associated with the
treatment assignment variable below and above the curoff.} \item{nr_t}{The
null-restricted t statistic to mitigate weak identification in a fuzzy RD.
The second element is the bias-corrected and s.e.-adjusted version of this
test.}
}
\description{
This function computes the local composite quantile regression
(LCQR) estimator of treatment effect for both sharp and fuzzy regression
discontinuity (RD) designs. It also computes the bias- corrected estimator
and adjusts its standard error by incorporating the variability due to
bias-correction.
}
\details{
This is the main function of the package and it estimates the
treatment effect for both sharp and fuzzy RD designs. The LCQR estimate is
obtained from an iterative algorithm and the estimation speed is much
slower compared to that of the lcoal linear regression. Most computation
time is spend on the calculation of the standard errors. By default, the
code to compute the standard error and bandwidth is paralleled and the
argument \code{numThreads} is set to the number of physical cores on a
computer. The option \code{numThreads = "auto"} uses all available threads
on a computer.

To further speed up things, the option \code{llr.residuals = TRUE}. This is
particularly suitable when the sample size is large.

The two arguments \code{maxit} and \code{tol} have a large impact on the
computation speed. For example, using \code{maxit = 500} and \code{tol =
  1e-6} will take much longer to complete compared to the default setting,
though the results are more precise. Our limited experience with some of
the popular RD data suggests that the treatment effect can usually be
estimated precisely with low computation cost while the standard errors may
have non-negligible change when one changes \code{maxit} and \code{tol}.
This certainly depends on the data. One should experiment with different
settings during estimation.

In estimating the bandwidths \code{adj.mseone}, \code{adj.msetwo}, and
\code{msetwo}, we need an estimate for the second and third derivative of
the conditional mean function. By default, the second derivative is
estimated by a global quartic polynomial and the third derivative is
estimated by a global quintic polynomial. The option \code{ls.derivative},
when set to \code{FLASE}, uses the LCQR method for derivative
estimation.Sometimes it can be difficult for a nonparametric method such as
LCQR to estimate derivatives of higher order.
}
\examples{
\dontrun{
# An example of using the Head Start data.
data(headstart)
y = headstart$mortality
x = headstart$poverty

# Use the defaul rule-of-thumb bandwidth in estimation.
# Also use the residuals from a local linear regression to estimate the
# standard errors of LCQR.
rdcqr(y, x, bandwidth = "rot", llr.residuals = TRUE)

# Supply bandwidths to data below and above the cutoff 0.
# The \code{poverty} variable is preprocessed to have a cutoff equal to 0.
rdcqr(y, x, bandwidth = c(10, 3), llr.residuals = TRUE)

# Try the MSE-optimal bandwidths for data below and above the cutoff.
rdcqr(y, x, bandwidth = "msetwo", llr.residuals = TRUE)

# Use the default settings.
# This approach uses residuals from a LCQR estimation when computing the
# standard errors. It is slow for large data sets. By default, the option
\code{parallel = TRUE} is used.
rdcqr(y, x)
}
}
